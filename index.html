<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Atividade 3</title>
  <link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
  <div class="section">
    <h1>WizardsVideo</h1>
    <p>Danilo Misura de Oliveira                    - 11006514</p>
    <p>Gabriel da Fonseca Nunes                  - 11201921456<p>
    <p>Thiago Vinícius Pereira Graciano de Souza - 11201722589<p>
  </div>

  <div class="section">
    <h1 class="section-title">Anexos</h1>
    <p class="section-content">
      <p>
        <a href="https://github.com/GabrielFonsecaNunes/atividade3"> 
          Repo: Github Atividade 3
        </a>
      </p>
      </p>
      <a href="https://docs.opencv.org/4.x/de/d25/imgproc_color_conversions.html">Color conversions</a> 
      </p>
      <p>
        <a href="https://docs.opencv.org/4.x/df/d9d/tutorial_py_colorspaces.html"> 
          Programa de mudança do espaço RGB para HSV, e execute o programa com a webcam, e um objeto colorido.
        </a>
      </p>
      <p>
        <a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html"> 
          Color Space Conversions (nomes das constantes de conversao de espaço de cor):
        </a>
      </p>
    <p> 
  </div>

  <h1>Atividade 3</h1>

  <div class="section">
    <h2 class="section-title">Introdução</h2>
    <p class="section-content">
      O processamento de vídeo desempenha um papel fundamental em diversas áreas, 
      como visão computacional, realidade virtual, jogos, vigilância por vídeo, entre outros. 
      O foco deste laboratório é discutir sobre a teoria do espaço de cores e a partir 
      a biblioteca OpenCV e aplica-las em imagem e vídeo.<br> 
    </p>
    <p class="section-content">
      <h2 class="section-title">Objetivos</h2>
      <ul class="section-content">
        <li>Estudar e se aprofundar na teoria de conversão de cores.</li>
        <li>
          Aprender utilizar os métodos de conversão de cores do OpenCV  
        </li>
      </ul>
    </p>
      
  </div>

  <div class="section">
    <h2 class="section-title">Fundamentos Básicos</h2>
    <p class="section-content">

      <p class="section-content">
        O processamento de vídeo envolve a aplicação de técnicas para manipular, analisar e extrair informações de 
        sequências de imagens em movimento. Para realizar essas tarefas, utilizaremos a biblioteca OpenCV, uma poderosa 
        ferramenta para processamento de imagens e vídeos.       
      </p>
      <p class="section-content">        
        As principais operações básicas que iremos explorar incluem a leitura de imagens e vídeos a partir de arquivos,
        visualização de imagens em janelas, salvamento de imagens em arquivos, captura de imagens da câmera e gravação de vídeos da câmera.
        Além disso, iremos aprender sobre diferentes aspectos, como a velocidade de exibição das imagens em vídeo, a alteração da imagem
        exibida em tempo real, e a realização de operações de processamento de imagem nos programas estudados       
      </p>

      <p class="section-content">        
        Antes de iniciar o trabalho com processamento, é imprescindível obter um melhor entendimento 
        de alguns conceitos fundamentais relacionados ao processamento de vídeo. 
      </p>

      <p class="section-content">
        <b>Imagem e Vídeo</b>: Imagens são representações visuais de objetos, cenas ou fenômenos capturados através de dispositivos ópticos, 
        como câmeras fotográficas ou sensores de imagem. Elas são compostas por uma matriz de elementos chamados de pixels, que são os
        pontos básicos de informação que compõem a imagem.

        Cada pixel contém informações sobre a cor e a intensidade luminosa em um determinado ponto da imagem. Essas informações são armazenadas
        e processadas digitalmente, permitindo a exibição, manipulação e análise das imagens em dispositivos eletrônicos, como computadores, 
        smartphones, tablets e telas de visualização.
        
        As imagens podem ser classificadas em diferentes tipos, como imagens em preto e branco (tons de cinza), imagens em escala de cores 
        (RGB - vermelho, verde e azul) ou imagens em outros espaços de cores, como YUV ou HSV. Além disso, as imagens podem ser estáticas, 
        representando uma única cena, ou sequenciais, formando um vídeo.
        
        No contexto do processamento de vídeo, as imagens são essenciais para realizar diversas tarefas, como detecção de objetos,
        reconhecimento de padrões, análise de movimento, segmentação de objetos, entre outras aplicações. O processamento das imagens
        permite extrair informações relevantes e realizar transformações que podem melhorar sua qualidade, ressaltar características
        ou facilitar a interpretação dos dados visuais.  
      </p>  
      
      <p class="section-content">
        <b>Pixel e Matriz de Pixels</b>: Um pixel é o menor elemento em uma imagem ou quadro de vídeo e representa um valor
        numérico que define sua cor ou intensidade. Uma matriz de pixels é uma grade bidimensional de pixels que compõem uma imagem ou quadro de vídeo.
      </p>

      <p class="section-content">
        <b>Filtros</b>: No processamento de imagens, um filtro é uma função matemática que é aplicada a cada pixel de uma imagem.
        O filtro pode ser usado para melhorar a qualidade da imagem, remover ruído ou adicionar efeitos.

        Alguns exemplos de filtros de processamento de imagens incluem:
        <ul class="section-content">
          <li>Filtros de nitidez: esses filtros aumentam o contraste entre os pixels de uma imagem, tornando-a mais nítida. </li>
          <li>Filtros de suavização: esses filtros reduzem o contraste entre os pixels de uma imagem, tornando-a mais suave. </li>
          <li>Filtros de ruído: esses filtros removem o ruído de uma imagem, tornando-a mais limpa. </li>
          <li>Filtros de efeitos: esses filtros adicionam efeitos especiais a uma imagem, como desfoque, vinheta ou preto e branco. </li>
        </ul>
      </p>

      <p class="section-content">
        <b> Espaço de cores: </b>Um espaço de cores é um modelo matemático para representar cores. Ele define como as cores são representadas e quantizadas, 
        e como elas são interpretadas pelo olho humano.
      </p>
      <p class="section-content">
        Os espaços de cores são importantes para o processamento de vídeo porque eles permitem que as cores sejam manipuladas de forma precisa e consistente.
        Eles também são importantes para a reprodução de cores precisas em diferentes dispositivos, como monitores, TVs e impressoras.
      </p>
      <p class="section-content">
        Existem muitos espaços de cores diferentes disponíveis, cada um com suas próprias vantagens e desvantagens. Alguns dos espaços de cores mais comuns para processamento de vídeo incluem:
        <ul class="section-content">
          <li><b>RGB</b>: O espaço de cores RGB é o mais comumente usado em processamento de vídeo. Ele é baseado na mistura de três componentes de cores primárias: vermelho, verde e azul. </li>
          <li><b>YUV:</b> O espaço de cores YUV é um espaço de cores de componentes de luminância e croma. Ele é frequentemente usado para compressão de vídeo, pois é mais eficiente do que RGB.</li>
          <li><b>HSV:</b> O espaço de cores HSV é um espaço de cores de matiz, saturação e valor. Ele é frequentemente usado para processamento de imagem, pois é fácil de entender e manipular.</li>
        </ul>
      </p>
      <p class="section-content">
        A escolha do espaço de cores correto para um determinado aplicativo depende de uma variedade de fatores, incluindo a qualidade de reprodução de cores desejada, o tamanho do arquivo de
        vídeo e as limitações do dispositivo de reprodução.
      </p>
      <p class="section-content">
        Correção de cores: Os espaços de cores podem ser usados para corrigir cores incorretas ou desbotadas em um vídeo.
        Edição de vídeo: Os espaços de cores podem ser usados para manipular cores em um vídeo, como alterar a saturação ou a temperatura da cor.
        Compressão de vídeo: Os espaços de cores podem ser usados para comprimir vídeos, reduzindo o tamanho dos arquivos sem perder muita qualidade.
        Reprodução de vídeo: Os espaços de cores podem ser usados para garantir que as cores de um vídeo sejam reproduzidas de forma precisa em diferentes dispositivos.
      </p>
    </p>
  </div>
  
  <div class="section">
    <h2 class="section-title">Materiais e Métodos</h2>
    <h2 class="section-title">Materiais</h2>
    <p class="section-content">
      A seguir, apresentamos os materiais utilizados em conjunto com suas respectivas descrições, a fim de criar um ambiente de trabalho adequado para a realização da 
      atividade prática no laboratório de Processamento de Vídeo. Esses materiais possibilitam a aquisição, manipulação e processamento eficiente e preciso de imagens e vídeos:
    </p class="section-content">  
    <p class="section-content">
      <ul class="section-content">
        <li class="item">Sistema Operacional Ubuntu 22.04: O sistema operacional Ubuntu 22.04 é uma distribuição Linux amplamente reconhecida pela sua estabilidade e facilidade de uso. Sua utilização
          no laboratório proporciona um ambiente propício para a execução dos programas e tarefas relacionados ao processamento de vídeo.</li>
        <li class="item">Webcam Digital Usb: Essa webcam é utilizada para realizar aquisição de imagens em tempo real durante as atividades práticas do laboratório.</li>
        <li class="item">Linguagem: Python é uma linguagem de programação popular e de alto nível, amplamente utilizada no processamento de vídeo devido à sua facilidade de uso e à 
          disponibilidade de bibliotecas poderosas. Neste laboratório, é utilizada a versão 3.10 ou superior do Python.</li>
        <li class="item">Bibliotecas OpenCV (4.7), Numpy (1.19.5): O OpenCV (Open Source Computer Vision) é uma biblioteca de código aberto amplamente utilizada para o processamento de
          imagem e vídeo. O Numpy é uma biblioteca para Python que oferece suporte a arrays multidimensionais e funções matemáticas avançadas. Ambas as bibliotecas são utilizadas
          para manipular e processar imagens e vídeos no laboratório.</li>
        <li class="item">IDE Visual Studio Code: Visual Studio Code: O Visual Studio Code é uma IDE (Integrated Development Environment) popular e de código aberto, que fornece um ambiente de
          desenvolvimento completo para escrever, depurar e executar programas em Python. É a IDE escolhida para o desenvolvimento das atividades práticas durante o laboratório.</li>
      </ul>
    </p> 
    <h2 class="section-title">Métodos</h2>
    <p class="section-content">      
      O desenvolvimento do trabalho será feito em três partes. Nesta primeira parte devemos: 1.a) Estudaremos e executaremos o <a href="https://docs.opencv.org/4.x/df/d9d/tutorial_py_colorspaces.html"> 
        programa disponível </a> fornecido para converter imagens do espaço RGB para HSV, a fim de fazer o rastreamento de uma cor em um objeto colorido.
        Nesta segunda parte, devemos fazer: 2.a) - Modificar o programa para salvar as imagens da webcam, da máscara e do resultado ao toque de uma tecla.</li>
        2.b) - Modificar o programa realizar o rastreamento de uma cor, e aplicar na imagem resultante (imagem depois do mascaramento) 
        um dos filtros da aula anterior, na imagem de entrada da webcam, tal que a imagem fique visualmente agradável. 2.c) Adicionalmente modifique o programa para gravar
        um video dos experimentos de rastreamento. Na última parte, 3.a) será feito feito outro programa para extrair mais de um objeto colorido, por exemplo, será feita o rastreamento objetos vermelhos, azuis e verdes simultaneamente.   
    </p>
      
    </p>
    <div class="section-content">
      Abaixo segue o programa estudado para converter imagens do espaço RGB para HSV, a fim de fazer o rastreamento de uma cor em um objeto colorido e sua descrição de funcionamento.
    </div>
    <div class="title">Programa rastreamento de objeto por mascara de cor Lab_1a.py</div>
    <div class="code-container" id="component-1">
      <textarea readonly>
import cv2 as cv
import numpy as np
cap = cv.VideoCapture(0)

while(1):
    # Take each frame
    _, frame = cap.read()
    # Convert BGR to HSV
    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
    # define range of blue color in HSV
    lower_blue = np.array([110,50,50])
    upper_blue = np.array([130,255,255])
    # Threshold the HSV image to get only blue colors
    mask = cv.inRange(hsv, lower_blue, upper_blue)
    # Bitwise-AND mask and original image
    res = cv.bitwise_and(frame,frame, mask= mask)
    cv.imshow('frame',frame)
    cv.imshow('mask',mask)
    cv.imshow('res',res)
    k = cv.waitKey(5) & 0xFF
    if k == 27:
        break
cv.destroyAllWindows()  
      </textarea>
      <button class="copy-button" onclick="copyCode('component-1')">Copiar</button>
    </div>
    <div class="section-content">
      O programa captura o vídeo da câmera, converte-o para o espaço de cores HSV e segmenta a região azul dentro de uma faixa 
      especificada. Os quadros originais, a máscara binária da cor azul e a imagem resultante são exibidos em janelas separadas. 
      O programa é encerrado ao pressionar a tecla "q". Segue abaixo o print da tela da execução do programa padrão.
    </div>
    <p class="title">Imagens Mascara Rastreamento Azul L3_1a.py</p>
    <div>
      <img src="img/img_program_default.jpg">
    </div>
  </div>
  <div class="section-content">
    Abaixo segue o programa modificado para salvar a imagem após apertar uma tecla juntamente com seu diagrama de blocos e imagens.
  </div>
  <p class="title">Programa L3_2a.py</p>
  <div class="code-container" id="component-1">
    <textarea readonly>
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

cap = cv.VideoCapture(0)

while(True):
    # Take each frame
    _, frame = cap.read()
    # Convert BGR to HSV
    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
    # define range of blue color in HSV
    lower_blue = np.array([110,50,50])
    upper_blue = np.array([130,255,255])
    # Threshold the HSV image to get only blue colors
    mask = cv.inRange(hsv, lower_blue, upper_blue)
    # Bitwise-AND mask and original image
    res = cv.bitwise_and(frame,frame, mask= mask)
    cv.imshow('frame',frame)
    cv.imshow('mask',mask)
    cv.imshow('res',res)
    
    k = cv.waitKey(3)
    if k == ord("q"):
        cv.imwrite(filename="Controle_Original.jpg", img= frame)
        cv.imwrite(filename="Controle_Mask.jpg", img= mask)
        cv.imwrite(filename="Controle_Res.jpg", img = res)
        break

cv.destroyAllWindows()  
    </textarea>
    <button class="copy-button" onclick="copyCode('component-1')">Copiar</button>
  </div>
  <p class="title">Diagrama Blocos Mascaramento de Cor com salvamento da Imagem</p>
  <div>
    <img src="img/diagrama_01.png" alt="Diagrama" class="fluxograma">
  </div>
  <p class="section-content">
    Imagens Programa L3_2a.py
  </p>
  <div>
    <img src="img/Controle_Original.jpg" alt="Diagrama" class="fluxograma">
  </div>
  <div>
    <img src="img/Controle_Mask.jpg" alt="Diagrama" class="fluxograma">
  </div>
  <div>
    <img src="img/Controle_Res.jpg" alt="Diagrama" class="fluxograma">
  </div>
  <div class="section-content">
    Com base no programa anterior, foi adicionado um filtro Gaussiano ao programa para suavizar regiões que o mascaramento pela cor não conseguiu preservar devido a algum ruído.
    Segue abaixo o programa com a adição da aplicação do filtro Gaussiano, juntamente com seu diagrama de blocos:
  </div>
  <p class="title">Programa L3_2b.py</p>
  <div class="code-container" id="component-1">
    <textarea readonly>
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

cap = cv.VideoCapture(0)

while(True):
    # Take each frame
    _, frame = cap.read()
    # Convert BGR to HSV
    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
    # define range of blue color in HSV
    lower_blue = np.array([90,50,50])
    upper_blue = np.array([130,255,255])
    # Threshold the HSV image to get only blue colors
    mask = cv.inRange(hsv, lower_blue, upper_blue)
    # Apply Gaussian Bluer Filter
    mask_filter = cv.GaussianBlur(mask, (3, 3), 0)
    # Bitwise-AND mask and original image
    res = cv.bitwise_and(frame,frame, mask= mask)
    cv.imshow('frame',frame)
    cv.imshow('mask',mask)
    cv.imshow('res',res)
    
    k = cv.waitKey(3)
    if k == ord("q"):
        cv.imwrite(filename="Controle_Original_b.jpg", img= frame)
        cv.imwrite(filename="Controle_Mask_b.jpg", img= mask)
        cv.imwrite(filename="Controle_Res_b.jpg", img = res)
        break

cv.destroyAllWindows()
    </textarea>
    <button class="copy-button" onclick="copyCode('component-1')">Copiar</button>
  </div>
  <div>
    <img src="img/diagrama_02.png" alt="Diagrama" class="fluxograma">
  </div>
  <p class="section-content">
    Imagens Programa L3_2b.py
  </p>
  <div>
    <img src="img/Controle_Original_b.jpg" alt="Diagrama" class="fluxograma">
  </div>
  <div>
    <img src="img/Controle_Mask_b.jpg" alt="Diagrama" class="fluxograma">
  </div>
  <div>
    <img src="img/Controle_Res_b.jpg" alt="Diagrama" class="fluxograma">
  </div>
  <p class="section-content">
    Foi feito alteração no programa anterior para gravação de cada janela (imagem, mascara, mascara com residuo) e alteração no filtro de cores de azul para laranja 
    (cor do controle). Segue abaixo o programa com modificação L3_2c.py para gravação juntamente com seu diagrama de blocos:
  </p>
  <p class="title">Programa L3_2c.py</p>
  <div class="code-container" id="component-1">
    <textarea readonly>
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

# Video Capture
cap = cv.VideoCapture(0)

# Obtém as dimensões do vídeo original
frame_width = int(cap.get(3))
frame_height = int(cap.get(4))

# VideoWriter
out_origin = cv.VideoWriter("output_origin.webm", cv.VideoWriter_fourcc(*'VP80'), 20, (frame_width, frame_height))

# VideoWriter
out_mask = cv.VideoWriter("output_mask.webm", cv.VideoWriter_fourcc(*'VP80'), 20, (frame_width, frame_height))

# VideoWriter
out_res = cv.VideoWriter("output_res.webm", cv.VideoWriter_fourcc(*'VP80'), 20, (frame_width, frame_height))

while(True):
  # Take each frame
  _, frame = cap.read()
  # Convert BGR to HSV
  hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
  
  # define range of blue color in HSV
  lower_orange = np.array([0, 100, 100])
  upper_orange = np.array([30, 255, 255])
  # Threshold the HSV image to get only blue colors
  mask = cv.inRange(hsv, lower_orange, upper_orange)
  # Apply Gaussian Bluer Filter
  mask_filter = cv.GaussianBlur(mask, (3, 3), 0)
  
  # Bitwise-AND mask and original image
  res = cv.bitwise_and(frame,frame, mask= mask)
  
  cv.imshow('frame',frame)
  cv.imshow('mask',mask)
  cv.imshow('res',res)

  # Escreve o frame no arquivo de vídeo
  out_origin.write(frame)
  # Escreve o frame no arquivo de vídeo
  out_mask.write(mask_filter)
  # Escreve o frame no arquivo de vídeo
  out_res.write(res)    

  q = cv.waitKey(3)
  if q == ord("q"):
      break

out_origin.release()
out_mask.release()
out_res.release()
cap.release()
cv.destroyAllWindows()
  </textarea>
  <button class="copy-button" onclick="copyCode('component-1')">Copiar</button>
</div>
<div>
  <img src="img/diagrama_03.png" alt="Diagrama" class="fluxograma">
</div>
<p>
  <video width="640" height="480" controls>
    <source src="video/output_origin.webm" type="video/webm">
    Seu navegador não suporta o elemento de vídeo.
  </video>      
</p>
<p>
  <video width="640" height="480" controls>
    <source src="video/output_res.webm" type="video/webm">
    Seu navegador não suporta o elemento de vídeo.
  </video>      
</p> 
<div class="section-content">
  Foi feito alteração no programa anterior para gravação de cada janela (imagem, mascara, mascara com residuo) para combinar o rastreamento de duas cores simultaneamente (Laranja e azul). 

  Segue abaixo o programa com modificação L3_3a.py para gravação juntamente com seu diagrama de blocos: 
</div> 
<p class="title">Programa L3_3a.py</p>
<div class="code-container" id="component-1">
  <textarea readonly>
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

# Video Capture
cap = cv.VideoCapture(0)

# Obtém as dimensões do vídeo original
frame_width = int(cap.get(3))
frame_height = int(cap.get(4))

# VideoWriter
out_origin = cv.VideoWriter("output_origin_combined.webm", cv.VideoWriter_fourcc(*'VP80'), 20, (frame_width, frame_height))

# VideoWriter
out_mask = cv.VideoWriter("output_mask_combined.webm", cv.VideoWriter_fourcc(*'VP80'), 20, (frame_width, frame_height))

# VideoWriter
out_res = cv.VideoWriter("output_res_combined.webm", cv.VideoWriter_fourcc(*'VP80'), 20, (frame_width, frame_height))

while(True):
    # Take each frame
    _, frame = cap.read()

    # Apply Gaussian Bluer Filter
    frame = cv.GaussianBlur(frame, (3, 3), 0)

    # Convert BGR to HSV
    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
    
    # define range of blue color in HSV
    lower_blue = np.array([90,50,50])
    upper_blue = np.array([130,255,255])
    
    # define range of blue color in HSV
    lower_orange = np.array([0, 100, 100])
    upper_orange = np.array([30, 255, 255])

    # Criando as máscaras para as cores laranja e azul
    mask_orange = cv.inRange(hsv, lower_orange, upper_orange)
    mask_blue = cv.inRange(hsv, lower_blue, upper_blue)

    # Combinando as máscaras
    combined_mask = cv.bitwise_or(mask_orange, mask_blue)

    # Aplicando a máscara combinada à imagem original
    res = cv.bitwise_and(frame, frame, mask=combined_mask)
    
    cv.imshow('frame',frame)
    cv.imshow('mask',combined_mask)
    cv.imshow('res',res)

    # Escreve o frame no arquivo de vídeo
    out_origin.write(frame)
    # Escreve o frame no arquivo de vídeo
    out_mask.write(combined_mask)
    # Escreve o frame no arquivo de vídeo
    out_res.write(res)    

    q = cv.waitKey(3)
    if q == ord("q"):
        break

out_origin.release()
out_mask.release()
out_res.release()
cap.release()
cv.destroyAllWindows()
    </textarea>
    <button class="copy-button" onclick="copyCode('component-1')">Copiar</button>
  </div>
  <div>
    <img src="img/diagrama_04.png" alt="Diagrama" class="fluxograma">
  </div>
  <p>
    <video width="640" height="480" controls>
      <source src="video/output_origin_combined.webm" type="video/webm">
      Seu navegador não suporta o elemento de vídeo.
    </video>      
  </p>  
  <p>
    <video width="640" height="480" controls>
      <source src="video/output_res_combined.webm" type="video/webm">
      Seu navegador não suporta o elemento de vídeo.
    </video>      
  </p> 
  <div class="section">
    <h2 class="section-title">Resultados e Análises</h2>
    <p class="section-content">
      Durante a execução das atividades propostas, foram obtidos os seguintes resultados:
    </p>
    <p class="section-content">
      Foram realizadas diversas iterações das atividades propostas, desde a conversão de imagens do espaço RGB para o espaço de cores HSV, passando pela aplicação de máscaras para o rastreamento de cores específicas, até a combinação de múltiplas máscaras para rastreamento simultâneo de diferentes cores. 
      Observou-se que a abordagem de segmentação por cores apresenta uma abordagem eficaz para identificação e rastreamento de objetos coloridos em vídeos em tempo real.
      Além disso, a adição de filtros como o filtro Gaussiano permitiu suavizar regiões que poderiam ser afetadas por ruído, melhorando a qualidade do rastreamento.
      A combinação de máscaras de cores diferentes possibilitou a detecção de múltiplos objetos simultaneamente, expandindo as capacidades do sistema de rastreamento.
    </p>
  </div>
  <div class="section">
    <h2 class="section-title">Conclusões e Comentários Finais</h2>
    <p class="section-content">
      Neste laboratório, exploramos os fundamentos do processamento de vídeo utilizando a biblioteca OpenCV e a linguagem Python. Através das atividades propostas, foi possível compreender como converter imagens entre diferentes espaços de cores, aplicar máscaras para rastreamento de cores específicas, realizar filtragem de imagens e combinar múltiplas máscaras para rastreamento simultâneo.
      O uso de filtros como o filtro Gaussiano permitiu melhorar a qualidade do rastreamento, suavizando regiões afetadas por ruído.
      Além disso, a aplicação do conhecimento teórico sobre espaços de cores e processamento de imagens em casos práticos demonstrou a importância desses conceitos em aplicações de visão computacional.
      Este laboratório contribuiu para a ampliação do entendimento sobre processamento de vídeo, fornecendo habilidades práticas para o desenvolvimento de sistemas de rastreamento de objetos em tempo real.
    </p>
  </div>

  <script src="src/script.js"></script>

  <div class="references">
    <h2 class="references-title">Referências</h2>
    <ol class="reference-list">
      <li class="reference-item">OpenCV. "Smoothing Images (OpenCV-Python Tutorials)": <link href="https://docs.opencv.org/4.x/d4/d13/tutorial_py_filtering.html"> https://docs.opencv.org/4.x/d4/d13/tutorial_py_filtering.html</li>
      <li class="reference-item"> MINICHINO, J. HOWSE, J., Learning OpenCV 3 Computer Vision with Python, 2nd Ed, Packt
        Publishing, 2015</li>
      <li class="reference-item">Tutorial OpenCV e Python: <link href="https://docs.opencv.org/master/d6/d00/tutorial_py_root.html"> https://docs.opencv.org/master/d6/d00/tutorial_py_root.html  </li>
      <li class="reference-item">Getting Started with Videos: <link href="https://docs.opencv.org/master/d6/d00/tutorial_py_root.html"> https://docs.opencv.org/4.x/dd/d43/tutorial_py_video_display.html</li>
      <li class="reference-item">Getting Started with Images: <link href="https://docs.opencv.org/4.x/db/deb/tutorial_display_image.html"> https://docs.opencv.org/4.x/db/deb/tutorial_display_image.html</li>
    </ol>
  </div>
</body>

</html>